'use client';

import React, { useEffect, useState } from 'react';

interface ExploitSuccessAnimationProps {
  isActive: boolean;
  bounty: number;
  targetName: string;
  signature: string;
  onComplete?: () => void;
}

export default function ExploitSuccessAnimation({ 
  isActive, 
  bounty, 
  targetName, 
  signature,
  onComplete 
}: ExploitSuccessAnimationProps) {
  const [phase, setPhase] = useState(0);
  const [showConfetti, setShowConfetti] = useState(false);

  useEffect(() => {
    if (!isActive) {
      setPhase(0);
      setShowConfetti(false);
      return;
    }

    // Animation phases
    const phases = [
      () => setPhase(1), // Glitch text appears
      () => setPhase(2), // Matrix decode effect
      () => { setPhase(3); setShowConfetti(true); }, // Success + confetti
      () => { setPhase(4); onComplete?.(); }, // Complete
    ];

    phases.forEach((fn, i) => {
      setTimeout(fn, (i + 1) * 800);
    });

    return () => {
      setPhase(0);
      setShowConfetti(false);
    };
  }, [isActive, onComplete]);

  if (!isActive) return null;

  return (
    <div className="fixed inset-0 z-[100] flex items-center justify-center bg-black/95">
      {/* Matrix Rain Background during animation */}
      <MatrixBurst isActive={phase >= 1} />
      
      {/* Glitch Text */}
      <div className={`relative text-center transition-all duration-500 ${phase >= 1 ? 'opacity-100 scale-100' : 'opacity-0 scale-50'}`}>
        {/* PWNED Text with heavy glitch */}
        <h1 
          className={`text-6xl md:text-9xl font-black tracking-tighter glitch-text animate-pulse ${
            phase >= 2 ? 'text-green-500' : 'text-red-600'
          }`}
          data-text="SYSTEM COMPROMISED"
        >
          {phase >= 2 ? '>>> PWNED <<<' : 'SYSTEM COMPROMISED'}
        </h1>

        {/* Decoding effect */}
        {phase >= 2 && (
          <div className="mt-8 space-y-4 font-mono text-sm md:text-base">
            <DecodeText text={`TARGET: ${targetName}`} delay={0} />
            <DecodeText text={`BOUNTY CLAIMED: ${bounty.toLocaleString()} $DSEC`} delay={200} />
            <DecodeText text={`SIGNATURE: ${signature.slice(0, 20)}...`} delay={400} />
            <DecodeText text={`STATUS: TRANSFERRED TO WALLET`} delay={600} className="text-green-400" />
          </div>
        )}

        {/* Success indicator */}
        {phase >= 3 && (
          <div className="mt-8 flex justify-center gap-2">
            {[...Array(5)].map((_, i) => (
              <div 
                key={i}
                className="w-4 h-4 bg-green-500 rotate-45 animate-bounce"
                style={{ animationDelay: `${i * 100}ms` }}
              />
            ))}
          </div>
        )}
      </div>

      {/* Red Confetti */}
      {showConfetti && <RedConfetti />}

      {/* Scanlines overlay */}
      <div className="absolute inset-0 pointer-events-none bg-[linear-gradient(transparent_50%,rgba(220,38,38,0.03)_50%)] bg-[length:100%_4px]" />

      {/* Close button on complete */}
      {phase >= 4 && (
        <button 
          onClick={() => onComplete?.()}
          className="absolute bottom-8 bg-red-600 text-black px-8 py-3 font-bold uppercase hover:bg-white transition-colors animate-pulse"
        >
          [ Continue ]
        </button>
      )}

      {/* Progress bar */}
      <div className="absolute bottom-0 left-0 right-0 h-1 bg-red-900/30">
        <div 
          className="h-full bg-green-500 transition-all duration-[3000ms] ease-out"
          style={{ width: phase >= 4 ? '100%' : `${phase * 25}%` }}
        />
      </div>
    </div>
  );
}

// Decoding text effect
function DecodeText({ text, delay, className = '' }: { text: string; delay: number; className?: string }) {
  const [displayText, setDisplayText] = useState('');
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%&*';

  useEffect(() => {
    const timeout = setTimeout(() => {
      let iteration = 0;
      const interval = setInterval(() => {
        setDisplayText(
          text
            .split('')
            .map((char, index) => {
              if (char === ' ') return ' ';
              if (index < iteration) return text[index];
              return chars[Math.floor(Math.random() * chars.length)];
            })
            .join('')
        );

        if (iteration >= text.length) {
          clearInterval(interval);
        }

        iteration += 1 / 3;
      }, 30);

      return () => clearInterval(interval);
    }, delay);

    return () => clearTimeout(timeout);
  }, [text, delay]);

  return (
    <div className={`text-red-400 ${className}`}>
      {displayText || text.split('').map(() => '█').join('')}
    </div>
  );
}

// Matrix burst effect
function MatrixBurst({ isActive }: { isActive: boolean }) {
  const canvasRef = React.useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    if (!isActive) return;
    
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const particles: Array<{
      x: number;
      y: number;
      char: string;
      speed: number;
      opacity: number;
      size: number;
    }> = [];

    // Create particles from center
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    for (let i = 0; i < 100; i++) {
      const angle = (Math.PI * 2 * i) / 100;
      particles.push({
        x: centerX,
        y: centerY,
        char: ['P', 'W', 'N', 'E', 'D', '0', '1', '█'][Math.floor(Math.random() * 8)],
        speed: 5 + Math.random() * 10,
        opacity: 1,
        size: 10 + Math.random() * 20,
      });
    }

    let animationId: number;
    const animate = () => {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      particles.forEach((p, i) => {
        const angle = (Math.PI * 2 * i) / particles.length;
        p.x += Math.cos(angle) * p.speed;
        p.y += Math.sin(angle) * p.speed;
        p.opacity -= 0.01;

        if (p.opacity > 0) {
          ctx.font = `bold ${p.size}px monospace`;
          ctx.fillStyle = `rgba(34, 197, 94, ${p.opacity})`;
          ctx.fillText(p.char, p.x, p.y);
        }
      });

      animationId = requestAnimationFrame(animate);
    };

    animate();

    return () => {
      cancelAnimationFrame(animationId);
    };
  }, [isActive]);

  if (!isActive) return null;

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none"
    />
  );
}

// Red confetti effect
function RedConfetti() {
  const canvasRef = React.useRef<HTMLCanvasElement>(null);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const pieces: Array<{
      x: number;
      y: number;
      rotation: number;
      speed: number;
      color: string;
      size: number;
    }> = [];

    const colors = ['#dc2626', '#991b1b', '#22c55e', '#7f1d1d', '#ef4444'];

    for (let i = 0; i < 150; i++) {
      pieces.push({
        x: Math.random() * canvas.width,
        y: -20 - Math.random() * 100,
        rotation: Math.random() * 360,
        speed: 2 + Math.random() * 4,
        color: colors[Math.floor(Math.random() * colors.length)],
        size: 5 + Math.random() * 10,
      });
    }

    let animationId: number;
    const animate = () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      pieces.forEach(p => {
        p.y += p.speed;
        p.rotation += 2;

        ctx.save();
        ctx.translate(p.x, p.y);
        ctx.rotate((p.rotation * Math.PI) / 180);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
        ctx.restore();
      });

      animationId = requestAnimationFrame(animate);
    };

    animate();

    const handleResize = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    };

    window.addEventListener('resize', handleResize);

    // Stop after 5 seconds
    const timeout = setTimeout(() => {
      cancelAnimationFrame(animationId);
    }, 5000);

    return () => {
      cancelAnimationFrame(animationId);
      clearTimeout(timeout);
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  return (
    <canvas
      ref={canvasRef}
      className="absolute inset-0 pointer-events-none z-50"
    />
  );
}
